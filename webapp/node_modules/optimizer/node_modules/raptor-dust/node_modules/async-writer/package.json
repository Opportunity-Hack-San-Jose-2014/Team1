{
  "name": "async-writer",
  "description": "The async-writer module makes it possible to asynchronously write data to an output stream while still flushing out bytes in the correct order",
  "repository": {
    "type": "git",
    "url": "https://github.com/raptorjs/async-writer.git"
  },
  "scripts": {
    "test": "mocha --ui bdd --reporter spec  ./test"
  },
  "author": {
    "name": "Patrick Steele-Idem",
    "email": "pnidem@gmail.com"
  },
  "maintainers": "Patrick Steele-Idem <pnidem@gmail.com>",
  "dependencies": {
    "events": "^1.0.2"
  },
  "devDependencies": {
    "mocha": "~1.15.1",
    "chai": "~1.8.1",
    "through": "^2.3.4"
  },
  "license": "Apache License v2.0",
  "bin": {},
  "main": "lib/async-writer.js",
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "version": "1.3.5",
  "readme": "async-writer\n============\n\nThe `async-writer` module makes it possible to asynchronously write to an output stream while still flushing out bytes in the correct order. That is, the `async-writer` module allows you to write parts of a stream out of order and the `async-writer` module does the hard work of ensuring that the output bytes are flushed in the correct order. Content that is written before it is ready to be flushed is buffered and immediately flushed as soon it is ready.\n\nAn async writer is helpful if during writing you have to wait for an asynchronous operation to complete before writing to part of a stream. As an example, you might start writing a page to produce HTML and then get to a part of the page that depends on data that has not yet been loaded. With that use case, you can continue to write the remainder of the page and still pipe out the stream to the response. The async writer will ensure that the bytes are flushed out in the correct order.\n\n# Installation\n\n```\nnpm install async-writer --save\n```\n\n# Usage\n\nThe simplest usage of an async writer is shown below:\n\n```javascript\nvar through = require('through');\n\nvar output = '';\nvar stream = through(function write(data) {\n        output += data;\n    });\n\nvar out = require('async-writer').create(stream)\n    .on('error', function(err) {\n        // Something went wrong during writing\n    })\n    .on('end', function() {\n        // Value of output: \"ABC\"\n    });\n\nout.write('A');\nout.write('B');\nout.write('C');\nout.end();\n```\n\nAsynchronous, out-of-order writing to an output stream is shown below:\n\n```javascript\nvar through = require('through');\n\nvar output = '';\nvar stream = through(function write(data) {\n        output += data;\n    });\n\nvar out = require('async-writer').create(stream)\n    .on('error', function(err) {\n        // Something went wrong during writing\n    })\n    .on('end', function() {\n        // Value of output: \"ABC\"\n    });\n\nout.write('A');\n\nvar asyncOut = out.beginAsync();\nsetTimeout(function() {\n    asyncOut.write('B');\n    asyncOut.end();\n}, 1000);\n\nout.write('C');\nout.end();\n```\n\nYou can also pipe another stream to a async writer. For example, the following code illustrates how multiple templates could be written to the same async writer:\n\n```javascript\nvar through = require('through');\n\nvar output = '';\nvar stream = through(function write(data) {\n        output += data;\n    });\n\nvar out = require('async-writer').create(stream)\n    .on('error', function(err) {\n        // Something went wrong during writing\n    })\n    .on('end', function() {\n        // Value of output: \"ABC\"\n    });\n\nout.write('A');\n\nvar asyncOut = out.beginAsync();\nrequire('fs').createReadStream('b.txt', 'utf8')\n    .pipe(asyncOut);\n\nout.write('C');\nout.end();\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/raptorjs/async-writer/issues"
  },
  "homepage": "https://github.com/raptorjs/async-writer",
  "_id": "async-writer@1.3.5",
  "_from": "async-writer@^1.1.0"
}
