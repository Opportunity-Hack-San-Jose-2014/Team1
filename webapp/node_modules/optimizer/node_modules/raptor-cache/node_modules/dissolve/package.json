{
  "name": "dissolve",
  "version": "0.3.3",
  "description": "Parse and consume binary streams with a neat DSL",
  "main": "index.js",
  "engines": {
    "node": "~0.10.0"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "dependencies": {
    "bl": "^0.7.0",
    "readable-stream": "^1.0.26"
  },
  "devDependencies": {
    "mocha": "~1.8.1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/deoxxa/dissolve.git"
  },
  "keywords": [
    "dissolve",
    "parse",
    "parser",
    "binary",
    "data",
    "stream",
    "event",
    "emit"
  ],
  "author": {
    "name": "Conrad Pankoff",
    "email": "deoxxa@fknsrs.biz",
    "url": "http://www.fknsrs.biz/"
  },
  "license": "BSD",
  "readme": "Dissolve\n========\n\nParse and consume binary streams with a neat DSL.\n\nOverview\n--------\n\nDissolve allows you to parse packed binary data into numbers, buffers, strings\nand more*! With a simple syntax inspired by [node-binary](https://github.com/substack/node-binary)\nand a solid, minimal implementation, you can be up and running in no time.\n\n(* implementing \"more\" is left as an exercise to the reader)\n\nIf you want to produce binary data, might I suggest [concentrate](https://github.com/deoxxa/concentrate)?\n\nFeatures\n--------\n\n* Accurate handling of [u]int{8,16,32} numbers in both signed and unsigned\n  variants using fast, built-in [Buffer](http://nodejs.org/docs/latest/api/buffer.html)\n  methods\n* Fast approximation of [u]int64 numbers in signed and unsigned variants\n* Extendable base class for building your own parsers and implementing\n  custom types\n* Tiny (~250 LoC) implementation, allowing for easy debugging\n\nInstallation\n------------\n\nAvailable via [npm](http://npmjs.org/):\n\n> $ npm install dissolve\n\nOr via git:\n\n> $ git clone git://github.com/deoxxa/dissolve.git node_modules/dissolve\n\nUsage\n-----\n\nAlso see [example.js](https://github.com/deoxxa/dissolve/blob/master/example.js),\n[example-complex.js](https://github.com/deoxxa/dissolve/blob/master/example-complex.js)\nand [example-loop.js](https://github.com/deoxxa/dissolve/blob/master/example-loop.js).\n\n```javascript\n#!/usr/bin/env node\n\nvar Dissolve = require(\"./index\");\n\nvar parser = Dissolve().loop(function(end) {\n  this.uint8(\"id\").tap(function() {\n    if (this.vars.id === 0x01) {\n      this.uint16be(\"a\").uint16be(\"b\");\n    } else if (this.vars.id === 0x02) {\n      this.uint32be(\"x\").uint32be(\"y\");\n    }\n  }).tap(function() {\n    this.push(this.vars);\n    this.vars = {};\n  });\n});\n\nparser.on(\"readable\", function() {\n  var e;\n  while (e = parser.read()) {\n    console.log(e);\n  }\n});\n\nparser.write(new Buffer([0x01, 0x00, 0x02, 0x00, 0x03])); // {id: 1, a: 2, b: 3}\nparser.write(new Buffer([0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05])); // {id: 2, x: 4, y: 5}\nparser.write(new Buffer([0x01]));\nparser.write(new Buffer([0x00, 0x02, 0x00]));\nparser.write(new Buffer([0x03])); // {id: 1, a: 2, b: 3}\n```\n\nMethods\n-------\n\nAll parser methods are chainable and return the same parser instance they were\ncalled on.\n\nTap\n---\n\n`tap(name, callback)`\n\nThis method allows you to \"tap\" into the parser at an arbitrary point. The\ncallback will be called bound to the parser instance, so you can use parser\nmethods on `this`. Any additional parser steps you introduce inside the callback\nwill be executed before any existing steps that are already scheduled to run\nafter the `tap` call.\n\nIf you provide a `name` parameter, all actions performed in the callback will be\napplied to a child object that will be put into a new property named after\n`name`. Note that in the callback, even if you provide a `name` parameter, you\ncan still pretend you were in the outer \"scope\" because of some prototype\ntrickery done with the `vars` object under the hood. You don't need to worry\nabout that too much, the examples should make it a bit clearer.\n\nLoop\n----\n\n`loop(name, callback)`\n\nThis method is like `tap` except that the callback is called over and over until\nsignalled to stop. You do this by calling the `end` function that's provided as\nthe first argument to your callback. When you call the `end` function, you can\nprovide an optional truthy/non-truthy flag to tell Dissolve to ignore the result\nof the iteration of the loop where `end` was called. This is useful if you are\nreading until a null entry or similar.\n\nIf you provide a `name` parameter, a new array will be placed into a property\nnamed for that parameter, and after each iteration of the loop, any new values\nwill be appended to the array as an object. As with the `name` stuff on `tap`,\nthe examples will make that explanation a lot clearer.\n\nThe same semantics for job ordering and \"scoping\" apply as for `tap`.\n\nBasic Parsing Methods\n---------------------\n\nFor each basic parsing method, the `name` value is the key under which the value\nwill be attached to `this.vars`.\n\nBuffer/String Methods\n---------------------\n\nFor these methods, the `length` parameter tells the parser how many bytes to\npull out. If it's a string, it will be assumed that it is the name of a\npreviously-set `this.vars` entry. If it's a number, it will be used as-is.\n\n* `buffer(name, length)` - binary slice\n* `string(name, length)` - utf8 string slice\n\nNumeric Methods\n---------------\n\n* `int8(name)` - signed 8 bit integer\n* `sint8(name)` - signed 8 bit integer\n* `uint8(name)` - unsigned 8 bit integer\n* `int16(name)` - signed, little endian 16 bit integer\n* `int16le(name)` - signed, little endian 16 bit integer\n* `int16be(name)` - signed, big endian 16 bit integer\n* `sint16(name)` - signed, little endian 16 bit integer\n* `sint16le(name)` - signed, little endian 16 bit integer\n* `sint16be(name)` - signed, big endian 16 bit integer\n* `uint16(name)` - unsigned, little endian 16 bit integer\n* `uint16le(name)` - unsigned, little endian 16 bit integer\n* `uint16be(name)` - unsigned, big endian 16 bit integer\n* `int32(name)` - signed, little endian 32 bit integer\n* `int32le(name)` - signed, little endian 32 bit integer\n* `int32be(name)` - signed, big endian 32 bit integer\n* `sint32(name)` - signed, little endian 32 bit integer\n* `sint32le(name)` - signed, little endian 32 bit integer\n* `sint32be(name)` - signed, big endian 32 bit integer\n* `uint32(name)` - unsigned, little endian 32 bit integer\n* `uint32le(name)` - unsigned, little endian 32 bit integer\n* `uint32be(name)` - unsigned, big endian 32 bit integer\n* `int64(name)` - signed, little endian 64 bit integer\n* `int64le(name)` - signed, little endian 64 bit integer\n* `int64be(name)` - signed, big endian 64 bit integer\n* `sint64(name)` - signed, little endian 64 bit integer\n* `sint64le(name)` - signed, little endian 64 bit integer\n* `sint64be(name)` - signed, big endian 64 bit integer\n* `uint64(name)` - unsigned, little endian 64 bit integer\n* `uint64le(name)` - unsigned, little endian 64 bit integer\n* `uint64be(name)` - unsigned, big endian 64 bit integer\n* `floatbe(data)` - big endian 32 bit float\n* `floatle(data)` - little endian 32 bit float\n* `doublebe(data)` - big endian 64 bit double\n* `doublele(data)` - little endian 64 bit double\n\nLicense\n-------\n\n3-clause BSD. A copy is included with the source.\n\nContact\n-------\n\n* GitHub ([deoxxa](http://github.com/deoxxa))\n* Twitter ([@deoxxa](http://twitter.com/deoxxa))\n* ADN ([@deoxxa](https://alpha.app.net/deoxxa))\n* Email ([deoxxa@fknsrs.biz](mailto:deoxxa@fknsrs.biz))\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/deoxxa/dissolve/issues"
  },
  "homepage": "https://github.com/deoxxa/dissolve",
  "_id": "dissolve@0.3.3",
  "_from": "dissolve@^0.3.3"
}
