{
  "name": "raptor-async",
  "description": "Simple library for orchestrating asynchronous operations",
  "repository": {
    "type": "git",
    "url": "https://github.com/raptorjs/raptor-async.git"
  },
  "scripts": {
    "test": "mocha --ui bdd --reporter spec ./test"
  },
  "author": {
    "name": "Phillip Gates-Idem",
    "email": "phillip.idem@gmail.com"
  },
  "maintainers": "Phillip Gates-Idem <phillip.idem@gmail.com>",
  "dependencies": {},
  "devDependencies": {
    "mocha": "~1.15.1",
    "chai": "~1.8.1"
  },
  "license": "Apache License v2.0",
  "bin": {},
  "main": "index.js",
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "version": "1.0.3",
  "readme": "raptor-async\n============\n\n**raptor-async** is a simple library for orchestrating asynchronous operations. It was inspired by the popular <a href=\"https://github.com/caolan/async\">caolan/async</a> library. The main difference being that this library only includes **parallel** and **series** functions. This library also supports an optional **thisObj** argument that determines the scope that will be used when invoking job and completion functions.\n\n# Overview\n\nThe **raptor-async** library handles invoking functions (a.k.a. jobs) in **parallel** or **series**. Each function is invoked with a single argument &mdash; a callback function that should be invoked when the job completes. The callback function is a Node-style callback so it expects the first parameter to be an error object and the second parameter to be the data.\n\n## Parallel\n\nThe **parallel** method is used to handle invoking worker jobs in parallel and notifying the provided callback when all of the jobs complete.\n\nThe **parallel** function supports the following calling conventions:\n```javascript\nasync.parallel(function[], function, thisObj)\n```\nor\n```javascript\nasync.parallel(object, function, thisObj)\n```\n\nIf **parallel** is invoked with an array of functions as first argument, then results will provided to the completion callback as an array with the value at each index corresponding to the data returned by the job at that index. The order of the results will not be arbitrary &mdash; it will always correspond to the order in which the jobs were provided to the **parallel** function.\n\nIf **parallel** is invoked with an object as first argument, then each property is expected to be a function. The results will provided to the completion callback as an object with the value of each property corresponding to the data returned by the job with the corresponding key.\n\nThe **thisObj** argument is optional, but if it is provided then each job function will be invoked in the scope of the given value. Also, the final completion callback will be invoked in the scope of the given value.\n\nExample of calling **parallel** with an array of functions as first argument:\n```javascript\nvar async = require('raptor-async');\n\nvar work = [];\n\nwork[0] = function(callback) {\n    setTimeout(function() {\n        callback(null, 0);\n    }, 1000);\n};\n\nwork[1] = function(callback) {\n    setTimeout(function() {\n        callback(null, 1);\n    }, 500);\n};\n\nwork[2] = function(callback) {\n    setTimeout(function() {\n        callback(null, 2);\n    }, 0);\n};\n\nasync.parallel(work, function(err, results) {\n    // results will be [0, 1, 2]\n});\n```\n\nExample of calling **parallel** with object as first argument:\n```javascript\nvar async = require('raptor-async');\n\nvar work = {};\n\nwork.a = function(callback) {\n    setTimeout(function() {\n        callback(null, 0);\n    }, 1000);\n};\n\nwork.b = function(callback) {\n    setTimeout(function() {\n        callback(null, 1);\n    }, 500);\n};\n\nwork.c = function(callback) {\n    setTimeout(function() {\n        callback(null, 2);\n    }, 0);\n};\n\nasync.parallel(work, function(err, results) {\n    // results will be {a: 0, b: 1, c: 2}\n});\n```\n\n## Series\n\nThe **series** method is used to handle invoking worker jobs in series and notifying the provided callback when all of the jobs complete. Execution of jobs will stop if a job provides an error to the callback. The results will always be an array whose order will correspond to the order in which the jobs were placed in array.\n\nThe **series** function supports the following calling convention:\n```javascript\nasync.series(function[], function, thisObj)\n```\n\nThe **thisObj** argument is optional, but if it is provided then each job function will be invoked in the scope of the given value. Also, the final completion callback will be invoked in the scope of the given value.\n\nExample of calling **series**:\n```javascript\nvar async = require('raptor-async');\n\nvar work = [];\n\nwork[0] = function(callback) {\n    setTimeout(function() {\n        callback(null, 0);\n    }, 1000);\n};\n\nwork[1] = function(callback) {\n    setTimeout(function() {\n        callback(null, 1);\n    }, 500);\n};\n\nwork[2] = function(callback) {\n    setTimeout(function() {\n        callback(null, 2);\n    }, 0);\n};\n\nasync.series(work, function(err, results) {\n    // results will be [0, 1, 2]\n});\n```\n\n## Error handling\n\nFor both **parallel** and **series** methods, if errors occur during execution of jobs then completion callback will be invoked with an error object as first argument.\n\nThe error object will have a **toMap** function that can be used to inspect which jobs returned errors. Each property in this map will have a key that corresponds to index (if input work was provided as array of functions) or key (if input work was provided as object) of original input job. The **toString** function will also provide a human-readable description of the error by invoking **toString** on each error and concatenating the results together in a meaningful way.\n\nFor example:\n```javascript\nvar async = require('raptor-async');\n\nasync.series(work, function(err, results) {\n    if (err) {\n        // toString can be used\n        console.error(err.toString());\n\n        // you can also examine the errors yourself and output a message\n        var mappedErrors = err.toMap();\n        for (var key in mappedErrors) {\n            console.error('Job \"' + key + '\" failed with error \"' + mappedErrors[key] + '\"';\n        }\n    }\n});\n```\n\nThrown exceptions will not be caught by **parallel** and **series** during invocations of jobs. It is responsibility of each job to provide their own try catch blocks if this is necessary.\n\n## DataHolder\n\nSometimes you need to keep track of an asynchronous operation to know if it is still pending, successfully completed or if it completed with an error. Promises allow for this, but Promises introduce a fair amount of overhead. The `DataHolder` class offered by this module can be used as a lightweight alternative to promises with a much more limited feature set. `DataHolder` instances do not support chaining, but they do support attaching Node.js-style callbacks. The usage of the `DataHolder` class is best described using code as shown below:\n\n```javascript\nvar DataHolder = require('raptor-async/DataHolder');\n\nvar configDataHolder = new DataHolder();\n\nfunction loadConfig() {\n    require('fs').readFile('config.json', 'utf8', function(err, json) {\n        if (err) {\n            // Something with wrong, I guess we won't be able to get a valid config...\n            return configDataHolder.reject(err);\n        }\n\n        var config = JSON.parse(json);\n\n        // Success! We completed the asynchronous operation of loading the config\n        // and now we can store the result in the async data holder instance.\n        configDataHolder.resolve(config);\n    });\n}\n\n// Start loading the config immediately\nloadConfig();\n\nexports.onConfigLoaded = function(callback) {\n    // Attach a listener to the data holder\n    configDataHolder.done(callback);\n}\n```\n\nThe constructor for the `DataHolder` supports an optional `options` argument (described later).\n\nThe most important methods provided by `DataHolder` instances are the following:\n\n- `resolve(data)` - Move the data holder ot the \"resolved\" state and store the resulting data in the data holder\n- `reject(err)` - Move the data holder ot the \"rejected\" state and store the resulting error in the data holder\n- `done(callback)` - Attach a Node.js-style callback to the data holder (i.e. `function(err, data)`). If the data holder has already been resolved then the provided callback will be invoked with the stored data as the second argument. If the data holder has already been rejected then the provided callback will be invoked with the stored error as the first argument. If the data holder has not been resolved or rejected then a listener will be attached and the listener will later be invoked when the data holder is later resolved or rejected.\n\nThe complete set of `DataHolder` properties are shown below:\n\n- `data` - The resolved data or `undefined` if the data holder has not been resolved\n- `error` - The rejected error or `undefined` if the data holder has not been rejected\n- `isResolved() : Boolean` - Has resolved been called?\n- `isRejected() : Boolean` - Has reject been called?\n- `isLoading() : Boolean` - Is there an outstanding request to load data via loader?\n- `isSettled() : Boolean` - Has reject or resolve been called?\n- `load(callback, scope)`\n- `done(callback, scope)`\n- `reject(err)`\n- `resolve(data)`\n- `reset(data)`\n- `unsettle(data)`\n\nThe signature for a `DataHolder` is `function DataHolder(options)` where options is an object with any of the following properties (all optional):\n\n- `loader` - A function that can be used to load the asynchronous data. The provided loader function will be invoked with a callback argument when `load()` is called or lazily when a `done` listener is added for the first time.\n- 'ttl' - A time-to-live in milliseconds. The data holder will go back into the initial unsettled state if the time-to-live is exceeded\n- `scope` - The default value of `this` when invoking any of the provided callbacks or the loader function\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/raptorjs/raptor-async/issues"
  },
  "homepage": "https://github.com/raptorjs/raptor-async",
  "_id": "raptor-async@1.0.3",
  "dist": {
    "shasum": "6762764f2dd2b5b55b90afef72df0ec15c206a59"
  },
  "_from": "raptor-async@^1.0.1",
  "_resolved": "http://registry.npmjs.org/raptor-async/-/raptor-async-1.0.3.tgz"
}
