{
  "name": "marko",
  "description": "Marko is an extensible, streaming, asynchronous, high performance, HTML-based templating language that can be used in Node.js or in the browser.",
  "keywords": [
    "templating",
    "template",
    "async",
    "streaming"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/raptorjs/marko.git"
  },
  "scripts": {
    "test": "mocha --ui bdd --reporter spec ./test && node_modules/.bin/jshint compiler/ runtime/ taglibs/"
  },
  "author": {
    "name": "Patrick Steele-Idem",
    "email": "pnidem@gmail.com"
  },
  "maintainers": [
    {
      "name": "Patrick Steele-Idem",
      "email": "pnidem@gmail.com"
    }
  ],
  "dependencies": {
    "async-writer": "^1.1.2",
    "char-props": "~0.1.5",
    "events": "^1.0.2",
    "htmlparser2": "^3.7.2",
    "marko-async": "^1.1.0",
    "marko-layout": "^1.1.0",
    "minimatch": "^0.2.14",
    "property-handlers": "^1.0.0",
    "raptor-args": "^1.0.0",
    "raptor-json": "^1.0.1",
    "raptor-logging": "^1.0.1",
    "raptor-modules": "^1.0.5",
    "raptor-polyfill": "^1.0.0",
    "raptor-promises": "^1.0.1",
    "raptor-regexp": "^1.0.0",
    "raptor-strings": "^1.0.0",
    "raptor-util": "^1.0.0",
    "sax": "^0.6.0"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "dustjs-linkedin": "^2.3.4",
    "jshint": "^2.5.0",
    "mocha": "~1.15.1",
    "raptor-cache": "^1.1.1",
    "raptor-data-providers": "^1.0.1-beta",
    "through": "^2.3.4"
  },
  "license": "Apache License v2.0",
  "bin": {
    "markoc": "bin/markoc"
  },
  "main": "runtime/marko-runtime.js",
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "version": "1.2.23",
  "readme": "Marko\n================\n\nMarko is an extensible, streaming, asynchronous, [high performance](https://github.com/raptorjs/templating-benchmarks), _HTML-based_ templating language that can be used in Node.js or in the browser. Marko was founded on the philosophy that an HTML-based templating language is more natural and intuitive for generating HTML.  Because the Marko compiler understands the structure of the HTML document, the directives in template files are less obtrusive and more powerful. In addition, Marko allows developers to introduce custom tags and custom attributes to extend the HTML grammar (much like [Web Components](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/)â€”only you can use it now).\n\n![Marko Syntax](syntax.png)\n\n![eBay Open Source](https://raw.githubusercontent.com/raptorjs/optimizer/master/images/ebay.png)\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n# Table of Contents\n\n- [Another Templating Language?](#another-templating-language)\n- [Design Philosophy](#design-philosophy)\n- [Sample Code](#sample-code)\n- [Installation](#installation)\n- [Usage](#usage)\n\t- [Template Rendering](#template-rendering)\n\t\t- [Callback API](#callback-api)\n\t\t- [Streaming API](#streaming-api)\n\t\t- [Synchronous API](#synchronous-api)\n\t\t- [Asynchronous Rendering API](#asynchronous-rendering-api)\n\t- [Browser-side Rendering](#browser-side-rendering)\n\t\t- [Using the RaptorJS Optimizer](#using-the-raptorjs-optimizer)\n\t\t- [Using Browserify](#using-browserify)\n\t- [Template Compilation](#template-compilation)\n\t\t- [Sample Compiled Template](#sample-compiled-template)\n- [Language Guide](#language-guide)\n\t- [Template Directives Overview](#template-directives-overview)\n\t- [Text Replacement](#text-replacement)\n\t- [Expressions](#expressions)\n\t- [Includes](#includes)\n\t- [Variables](#variables)\n\t- [Conditionals](#conditionals)\n\t\t- [if...else-if...else](#ifelse-ifelse)\n\t\t- [Shorthand conditionals](#shorthand-conditionals)\n\t- [Looping](#looping)\n\t\t- [for](#for)\n\t\t\t- [Loop Status Variable](#loop-status-variable)\n\t\t\t- [Loop Separator](#loop-separator)\n\t\t\t- [Range Looping](#range-looping)\n\t\t\t- [Property Looping](#property-looping)\n\t- [Macros](#macros)\n\t\t- [def](#def)\n\t\t- [invoke](#invoke)\n\t- [Structure Manipulation](#structure-manipulation)\n\t\t- [attrs](#attrs)\n\t- [Comments](#comments)\n\t- [Helpers](#helpers)\n\t- [Custom Tags and Attributes](#custom-tags-and-attributes)\n\t- [Async Taglib](#async-taglib)\n\t- [Layout Taglib](#layout-taglib)\n- [Custom Taglibs](#custom-taglibs)\n\t- [Tag Renderer](#tag-renderer)\n\t- [marko-taglib.json](#marko-taglibjson)\n\t\t- [Sample Taglib](#sample-taglib)\n\t\t- [Defining Tags](#defining-tags)\n\t\t\t- [Defining Attributes](#defining-attributes)\n\t\t- [Scanning for Tags](#scanning-for-tags)\n\t\t- [Nested Tags](#nested-tags)\n\t- [Taglib Discovery](#taglib-discovery)\n- [FAQ](#faq)\n- [Discuss](#discuss)\n- [Contributors](#contributors)\n- [Contribute](#contribute)\n- [License](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Another Templating Language?\n\nMost front-end developers are familiar with, and comfortable with, templating languages such as [Handlebars](https://github.com/wycats/handlebars.js), [Dust](https://github.com/linkedin/dustjs) or [Mustache](http://mustache.github.io/) so why was Marko introduced?\n\nWhat makes Marko different is that it is an HTML-based templating language that does not rely on a custom language grammar. Any HTML file is a valid Marko template and vice-versa, and the Marko compiler uses an [off-the-shelf HTML parser](https://github.com/fb55/htmlparser2). Because Marko understands the HTML structure of the templates, it can do more powerful things that would not be possible in a text-based templating languages such as Handlerbars, Dust or Mustache. Marko allows developers to _extend the HTML language_ by introducing custom HTML elements and attributes. On top of that, utilizing the HTML structure for applying templating directives makes templates more readable and allows data templates to more closely resemble the final HTML structure.\n\nLet's compare Marko with Handlebars (a text-based templating language):\n\n__Handlebars:__\n\n```html\nHello {{name}}!\n\n{{#if colors}}\n<ul>\n    {{#each colors}}\n    <li class=\"color\">\n        {{this}}\n    </li>\n    {{/each}}\n</ul>\n{{else}}\n<div>\n    No colors!\n</div>\n{{/if}}\n```\n\n__Marko:__\n\n```html\nHello ${data.name}!\n\n<ul if=\"notEmpty(data.colors)\">\n    <li class=\"color\" for=\"color in data.colors\">\n        ${color}\n    </li>\n</ul>\n<div else>\n    No colors!\n</div>\n```\n\nA few things to note for the Marko template:\n\n* Less lines of code\n* Less lines are \"touched\" to make the template dynamic\n* Only opening tags are modified for conditionals and looping\n\nBeyond Marko being an HTML-based templating language, it was also designed with extreme performance and extensibility in mind. The Marko compiler gives developers full control over how templates are compiled to JavaScript and the runtime was designed to be as efficient as possible. Marko fully embraces the JavaScript language for better performance and flexibility (e.g. favoring JavaScript expressions over a custom expression language).\n\nFinally, another distinguishing feature of Marko is that it supports _asynchronous template rendering_. This powerful feature allows portions of the template to be rendered asynchronously. Instead of waiting for all data to come back from remote services before beginning to render the template, you can now immediately start rendering the template and the portions of the template that depend on asynchronous data will render as soon as the asynchronous data becomes available. The Marko rendering engine ensures that the final HTML will be streamed out in the correct order.\n\n# Design Philosophy\n\n* __Readable:__ Templates should be as close to the output HTML as possible to keep templates readable. Cryptic syntax and symbols should be avoided.\n* __Simple:__ The number of new concepts should be minimized and complexity should be avoided.\n* __Extensible:__ The template engine should be easily extensible at both compile-time and runtime.\n* __High Performance:__ Runtime and compiled output should be optimized for low CPU and memory usage and have a small footprint. All expressions should be native JavaScript to avoid runtime interpretation.\n* __Not Restrictive:__ Whether or not to go less logic or more logic is up to the developer.\n* __Asynchronous and Streaming Output:__ It should be possible to render HTML out-of-order, but the output HTML should be streamed out in the correct order. This minimizes idle time and reduces the time to first byte.\n* __Intuitive:__ The templating engine should introduce as few surprises as possible.\n* __Browser and Server Compatibility:__ Templates should compile down to JavaScript that can be executed on both the server and the client.\n* __Debuggable:__ Compiled JavaScript should be debuggable and readable.\n* __Compile-Time Checks:__ Syntax, custom tags and custom attributes should be validated at compile-time.\n* __Tools Support:__ Tools should be enabled to offer auto-completion and validation for improved productivity and safety.\n* __Modular:__ Runtime and compiled templates should be based on CommonJS modules for improved dependency management. Template dependencies (such as custom tags) should be resolved based on a template's file system path instead of relying on a shared registry.\n\n# Sample Code\n\nA basic template with text replacement, looping and conditionals is shown below:\n\n```html\nHello ${data.name}!\n\n<ul if=\"notEmpty(data.colors)\">\n    <li style=\"color: $color\" for=\"color in data.colors\">\n        $color\n    </li>\n</ul>\n<div else>\n    No colors!\n</div>\n```\n\nThe template can then be rendered as shown in the following sample code:\n\n```javascript\nvar templatePath = require.resolve('./hello.marko');\nvar template = require('marko').load(templatePath);\n\ntemplate.render({\n        name: 'World',\n        colors: [\"red\", \"green\", \"blue\"]\n    },\n    function(err, output) {\n        console.log(output);\n    });\n```\n\nThe output of running the above program will be the following (formatted for readability):\n```html\nHello World!\n\n<ul>\n    <li>red</li>\n    <li>green</li>\n    <li>blue</li>\n</ul>\n```\n\nFor comparison, given the following data data consisting of an empty array of colors:\n\n```javascript\n{\n    name: 'World',\n    colors: []\n}\n```\n\nThe output would be the following:\n\n```html\nHello World!\n\n<div>No colors!</div>\n```\n\nThe streaming API can be used to stream the output to an HTTP response stream or any other writable stream. For example, with Express:\n\n```javascript\nvar template = require('marko').load(require.resolve('./template.marko'));\n\napp.get('/profile', function(req, res) {\n    template.stream({\n            name: 'Frank'\n        })\n        .pipe(res);\n});\n```\n\nMarko also supports custom tags so you can easily extend the HTML grammar to support things like the following:\n\n```html\nWelcome to Marko!\n\n<ui-tabs>\n    <ui-tab label=\"Home\">\n        Content for Home\n    </ui-tab>\n    <ui-tab label=\"Profile\">\n        Content for Profile\n    </ui-tab>\n    <ui-tab label=\"Messages\">\n        Content for Messages\n    </ui-tab>\n</ui-tabs>\n```\n\nThe above template is a very simple way to generate the much more complicated HTML output shown below:\n\n```html\n<div class=\"tabs\">\n    <ul class=\"nav nav-tabs\">\n        <li class=\"active\">\n            <a href=\"#tab0\" data-toggle=\"tab\">Home</a>\n        </li>\n        <li>\n            <a href=\"#tab1\" data-toggle=\"tab\">Profile</a>\n        </li>\n        <li>\n            <a href=\"#tab2\" data-toggle=\"tab\">Messages</a>\n        </li>\n    </ul>\n    <div class=\"tab-content\">\n        <div id=\"tab0\" class=\"tab-pane active\">\n            Content for Home\n        </div>\n        <div id=\"tab1\" class=\"tab-pane\">\n            Content for Profile\n        </div>\n        <div id=\"tab2\" class=\"tab-pane\">\n            Content for Messages\n        </div>\n    </div>\n</div>\n```\n\nThe custom tags encapsulate rendering logic and help avoid repeating the same HTML (and potentially the same mistakes).\n\n# Installation\n\nTo install the `marko` module into your project you should use the following command:\n```bash\nnpm install marko --save\n```\n\nTo install the optional `markoc` command line interface to compile templates you can use the following command:\n```bash\nnpm install marko --global\n```\n\n# Usage\n\n## Template Rendering\n\n### Callback API\n```javascript\nvar template = require('marko').load('template.marko');\n\ntemplate.render({\n        name: 'Frank',\n        count: 30\n    },\n    function(err, output) {\n        if (err) {\n            console.error('Rendering failed');\n            return;\n        }\n\n        console.log('Output HTML: ' + output);\n    });\n```\n\n### Streaming API\n\n```javascript\nvar template = require('marko').load('template.marko');\nvar out = require('fs').createWriteStream('index.html', 'utf8');\n\n// Render the template to 'index.html'\ntemplate.stream({\n        name: 'Frank',\n        count: 30\n    })\n    .pipe(out);\n```\n\nAlternatively, you can render directly to an existing stream to avoid creating an intermediate stream:\n\n```javascript\nvar template = require('marko').load('template.marko');\nvar out = require('fs').createWriteStream('index.html', 'utf8');\n\n// Render the template to 'index.html'\ntemplate.render({\n        name: 'Frank',\n        count: 30\n    }, out);\n```\n_NOTE:_ This will end the target output stream.\n\n### Synchronous API\n\nIf you know that your template rendering requires no asynchronous rendering then you can use the synchronous API to render a template to a String:\n\n```javascript\nvar template = require('marko').load('template.marko');\n\nvar output = template.renderSync({\n        name: 'Frank',\n        count: 30\n    });\nconsole.log('Output HTML: ' + output);\n```\n\n### Asynchronous Rendering API\n\n```javascript\nvar fs = require('fs');\nvar marko = require('marko');\nvar template = marko.load('template.marko');\n\nvar out = marko.createWriter(fs.createWriteStream('index.html', 'utf8'));\n\n// Render the first chunk asynchronously (after 1s delay):\nvar asyncOut = out.beginAsync();\nsetTimeout(function() {\n    asyncOut.write('BEGIN ');\n    asyncOut.end();\n}, 1000);\n\n// Render the template to the original writer:\ntemplate.render({\n        name: 'World'\n    },\n    out);\n\n// Write the last chunk synchronously:\nout.write(' END');\n\n// End the rendering out\nout.end();\n```\n\nDespite rendering the first chunk asynchronously, the above program will stream out the output in the correct order to `index.html`:\n\n```html\nBEGIN Hello World! END\n```\n\nFor more details, please see the documentation for the [async-writer](https://github.com/raptorjs/async-writer) module.\n\n## Browser-side Rendering\n\nGiven the following module code that will be used to render a template on the client-side:\n\n_run.js_:\n```javascript\n\nvar templatePath = require.resolve('./hello.marko');\nvar template = require('marko').load(templatePath);\n\ntemplatePath.render({\n        name: 'John'\n    },\n    function(err, output) {\n        document.body.innerHTML = output;\n    });\n```\n\nYou can then bundle up the above program for running in the browser using either [optimizer](https://github.com/raptorjs/optimizer) (recommended) or [browserify](https://github.com/substack/node-browserify).\n\n\n### Using the RaptorJS Optimizer\n\nThe `optimizer` CLI can be used to generate resource bundles that includes all application modules and all referenced Marko template files using a command similar to the following:\n```bash\n# First install the optimizer and the optimizer-marko plugin\nnpm install optimizer --global\nnpm install optimizer-marko\n\noptimizer --main run.js --name my-page --plugins optimizer-marko\n```\n\nThis will produce a JSON file named `build/my-page.html.json` that contains the HTML markup that should be used to include the required JavaScript and CSS resources that resulted from the page optimization.\n\nAlternatively, you can inject the HTML markup into a static HTML file using the following command:\n\n```bash\noptimizer --main run.js --name my-page --plugins optimizer-marko --inject-into my-page.html\n```\n\n\n### Using Browserify\n\nThe `markoify` transform for browserify must be enabled in order to automatically compile and include referenced Marko template files.\n\n```bash\n# Install the markoify plugin from npm:\nnpm install markoify --save\n\n# Build the browser bundle:\nbrowserify -t markoify run.js > browser.js\n```\n\n\n## Template Compilation\n\nThe Marko compiler produces a Node.js-compatible, CommonJS module as output. This output format has the advantage that compiled template modules can benefit from a context-aware module loader and templates can easily be transported to work in the browser using the [RaptorJS Optimizer](https://github.com/raptorjs/optimizer) or [Browserify](https://github.com/substack/node-browserify).\n\nThe `marko` module will automatically compile templates loaded by your application on the server, but you can also choose to precompile all templates. This can be helpful as a build or test step to catch errors early.\n\nYou can either use the command line interface or the JavaScript API to compile a Marko template file. To use the CLI you must first install the `marko` module globally using the following command:\n```bash\nnpm install marko --global\n```\n\nYou can then compile single templates using the following command:\n```bash\nmarkoc hello.marko\n```\n\nThis will produce a file named `hello.marko.js` next to the original file.\n\nYou can also recursively compile all templates in the current directory (the `node_modules` and `.*` directories will be ignored by default)\n\n```bash\nmarkoc .\n```\n\nYou can also specify multiple directories or files\n```bash\nmarkoc foo/ bar/ template.marko\n```\n\nTo delete all of the generated `*.marko.js` files you can add the `--clean` argument. For example:\n```bash\nmarkoc . --clean\n```\n\n\nAlternatively, you can use the JavaScript API to compile a module as shown in the following sample code:\n```javascript\nrequire('marko/compiler').compileFile(path, function(err, src) {\n    // Do something with the compiled output\n});\n```\n\n### Sample Compiled Template\n```javascript\nmodule.exports = function create(__helpers) {\n  var empty = __helpers.e,\n      notEmpty = __helpers.ne,\n      escapeXml = __helpers.x,\n      forEach = __helpers.f,\n      escapeXmlAttr = __helpers.xa;\n\n  return function render(data, out) {\n    out.w('Hello ' +\n      escapeXml(data.name) +\n      '! ');\n\n    if (notEmpty(data.colors)) {\n      out.w('<ul>');\n\n      forEach(data.colors, function(color) {\n        out.w('<li style=\"color: ' +\n          escapeXmlAttr(color) +\n          '\">' +\n          escapeXml(color) +\n          '</li>');\n      });\n\n      out.w('</ul>');\n    }\n    else {\n      out.w('<div>No colors!</div>');\n    }\n  };\n}\n```\n\nThe compiled output is designed to be both extremely readable and minifiable. The minified code is shown below:\n\n\n```javascript\nmodule.exports=function(a){var d=a.ne,c=a.x,e=a.f,f=a.xa;return function(a,b){b.w(\"Hello \"+c(a.name)+\"! \");d(a.colors)?(b.w(\"<ul>\"),e(a.colors,function(a){b.w('<li style=\"color: '+f(a)+'\">'+c(a)+\"</li>\")}),b.w(\"</ul>\")):b.w(\"<div>No colors!</div>\")}};\n```\n\n_File size: 190 bytes gzipped (251 bytes uncompressed)_\n\n\n# Language Guide\n\n## Template Directives Overview\n\nAlmost all of the Marko templating directives can be used as either an attribute or as an element. For example:\n\n_Applying directives using attributes:_\n```html\n<!-- Colors available -->\n<ul if=\"notEmpty(colors)\">\n    <li for=\"color in colors\">\n        $color\n    </li>\n</ul>\n\n<!-- No colors available -->\n<div if=\"empty(colors)\">\n    No colors!\n</div>\n```\n\n_Applying directives using elements:_\n```html\n<!-- Colors available -->\n<if test=\"notEmpty(colors)\">\n    <ul>\n        <for each=\"color in colors\">\n            <li>\n                $color\n            </li>\n        </for>\n    </ul>\n</if>\n\n<!-- No colors available -->\n<if test=\"empty(colors)\">\n    <div>\n        No colors!\n    </div>\n</if>\n```\n\nThe disadvantage of using elements to control structural logic is that they change the nesting of the elements which can impact readability. For this reason it is often more suitable to apply directives as attributes.\n\n## Text Replacement\n\nDynamic text is supported using either `$<variable-reference>` or `${<javascript-expression>}`.\n\nExamples:\n```html\nHello $data.name!\nHello ${data.name}!\nHello ${data.name.toUpperCase()}!\n```\n\nBy default, all special HTML characters will be escaped in dynamic text to prevent Cross-site Scripting (XSS) Attacks. To disable HTML escaping, you can use `$!` as shown in the following sample code:\n\n```html\nHello $!{data.name}! <!-- Do not escape -->\n```\n\nIf necessary, you can escape `$` using a forward slash to have it be treated as text instead of a placeholder token:\n\n```html\nTest: \\${hello}\n<!-- Rendered Ouptut:\nTest: ${hello}\n-->\n```\n\n## Expressions\n\nWherever expressions are allowed, they are treated as JavaScript expressions and copied out to the compiled template verbatim. However, you can choose to use alternate versions of the following JavaScript operators:\n\nJavaScript Operator | Marko Equivalent\n------------------- | -----------------\n`&&` \t            | `and`\n<code>&#124;&#124;</code>                | `or`\n`===`               | `eq`\n`!==`               | `ne`\n`<`                 | `lt`\n`>`                 | `gt`\n`<=`                | `le`\n`>=`                | `ge`\n\nFor example, both of the following are valid and equivalent:\n\n```html\n<div if=\"searchResults.length > 100\">\n    Show More\n</div>\n```\n\n```html\n<div if=\"searchResults.length gt 100\">\n    Show More\n</div>\n```\n\n## Includes\n\nOther Marko files can be included using the `<include>` tag and a relative path. For example:\n\n```html\n<include template=\"./greeting.marko\" name=\"Frank\" count=\"30\"/>\n```\n\n## Variables\n\nInput data passed to a template is made available using a special `data` variable. It's possible to declare your own variables as shown in the following sample code:\n\n```html\n<var name=\"name\" value=\"data.name.toUpperCase()\" />\n```\n\nThe `<with>` directive can be used to create scoped variables as shown in the following sample code:\n\n```html\n<with vars=\"nameUpper=data.name.toUpperCase(); nameLower=data.name.toLowerCase()\">\n    Hello $nameUpper!\n    Hello $nameLower!\n</with>\n```\n\n## Conditionals\n\n### if...else-if...else\n\nAny element or fragment of HTML can be made conditional using the `if`, `else-if` or `else` directive.\n\n_Applied as attributes:_\n```html\n<!--Simple if-->\n<div if=\"someCondition\">\n    Hello World\n</div>\n\n<!--Complex if-->\n<div if=\"test === 'a'\">\n    A\n</div>\n<div else-if=\"test === 'b'\">\n    B\n</div>\n<div else-if=\"test === 'c'\">\n    C\n</div>\n<div else>\n    Something else\n</div>\n```\n\n_Applied as elements:_\n```html\n<!-- Colors available -->\n<!--Simple if-->\n<if test=\"someCondition\">\n    <div>\n        Hello World\n    </div>\n</if>\n\n<!--Complex if-->\n<if test=\"test === 'a'\">\n    <div>\n        A\n    </div>\n</if>\n<else-if test=\"test === 'b'\">\n    <div>\n        B\n    </div>\n</else-if>\n<else-if test=\"test === 'c'\">\n    <div>\n        C\n    </div>\n</else-if>\n<else>\n    <div>\n        Something else\n    </div>\n</else>\n```\n\n### Shorthand conditionals\n\nShorthand conditionals allow for conditional values inside attributes or wherever expressions are allowed. Shorthand conditionals are of the following form:\n`{?<expression>;<true-template>[;<false-template>]}`\n\nFor example:\n\n```html\n<div class=\"{?active;tab-active}\">Hello</div>\n```\nWith a value of `true` for `active`, the output would be the following:\n\n```html\n<div class=\"tab-active\">Hello</div>\n```\n\nWith a value of `false` for `active`, the output would be the following:\n\n```html\n<div>Hello</div>\n```\n\n_NOTE: If the expression inside an attribute evaluates to `null` or an empty string then the attribute is not included in the output._\n\nAs shown in the previous example, the \"else\" block for shorthand conditionals is optional. The usage of an else block is shown below:\n\n```html\n<div class=\"{?active;tab-active;tab-inactive}\">Hello</div>\n```\n\nWith a value of `false` for `active`, the output would be the following:\n\n```html\n<div class=\"tab-inactive\">Hello</div>\n```\n\n## Looping\n\n### for\n\nAny element can be repeated for every item in an array using the `for` directive. The directive can be applied as an element or as an attribute.\n\n_Applied as an attribute:_\n\n```html\n<ul>\n    <li for=\"item in items\">${item}</li>\n</ul>\n```\n\n_Applied as an element:_\n\n```html\n<ul>\n    <for each=\"item in items\">\n        <li>${item}</li>\n    </for>\n</ul>\n```\n\n\nGiven the following value for items:\n\n```javascript\n[\"red\", \"green\", \"blue\"]\n```\n\nThe output would be the following:\n\n```html\n<ul>\n    <li>red</li>\n    <li>green</li>\n    <li>blue</li>\n</ul>\n```\n\n#### Loop Status Variable\n\nThe `for` directive also supports a loop status variable in case you need to know the current loop index. For example:\n\n```html\n<ul>\n    <li for=\"color in colors; status-var=loop\">\n        ${loop.getIndex()+1}) $color\n        <if test=\"loop.isFirst()\"> - FIRST</if>\n        <if test=\"loop.isLast()\"> - LAST</if>\n    </li>\n</ul>\n```\n\n#### Loop Separator\n\n```html\n<for each=\"color in colors\" separator=\", \">$color</for>\n\n<div>\n    <span for=\"color in colors; separator=', '\" style=\"color: $color\">$color</span>\n</div>\n```\n\n#### Range Looping\n\nA range can be provided in the following format; `<var-name> from <from> to <to>[ step <step>]`.\n\nThe `from`, `to` and `step` values must be numerical expressions. If not specified, step defaults to 1.\n\n```html\n<ul>\n    <li for=\"i from 0 to 10\">\n        $i\n    </li>\n</ul>\n```\n\n```html\n<ul>\n    <li for=\"i from 0 to 10 step 2\">\n        $i\n    </li>\n</ul>\n```\n\n```html\n<ul>\n    <li for=\"i from 0 to myArray.length-1\">\n        ${myArray[i]}\n    </li>\n</ul>\n```\n\n\n#### Property Looping\n\n```html\n<ul>\n    <li for=\"(name,value) in settings\">\n        <b>$name</b>:\n        $value\n    </li>\n</ul>\n```\n\n## Macros\n\nParameterized macros allow for reusable fragments within an HTML template. A macro can be defined using the `<def>` directive.\n\n### def\n\nThe `<def>` directive can be used to define a reusable function within a template.\n\n```html\n<def function=\"greeting(name, count)\">\n    Hello $name! You have $count new messages.\n</def>\n```\n\nThe above macro can then be invoked as part of any expression. Alternatively, the [`<invoke>`](#invoke) directive can be used invoke a macro function using named attributes. The following sample template shows how to use macro functions inside expressions:\n\n```html\n<def function=\"greeting(name, count)\">\n    Hello $name! You have $count new messages.\n</def>\n\n<p>\n    ${greeting(\"John\", 10)}\n</p>\n<p>\n    ${greeting(\"Frank\", 20)}\n</p>\n```\n\n### invoke\n\nThe `<invoke>` directive can be used to invoke a function defined using the `<def>` directive or a function that is part of the input data to a template. The `<invoke>` directive allows arguments to be passed using element attributes, but that format is only supported for functions that were previously defined using the `<def>` directive.\n\n```html\n<def function=\"greeting(name, count)\">\n    Hello ${name}! You have ${count} new messages.\n</def>\n\n<invoke function=\"greeting\" name=\"John\" count=\"${10}\"/>\n<invoke function=\"greeting('Frank', 20)\"/>\n```\n\nThe output for the above template would be the following:\n\n```html\n<p>\n    Hello John! You have 10 new messages.\n</p>\n<p>\n    Hello Frank! You have 20 new messages.\n</p>\n```\n\n_NOTE:_ By default, the arguments will be of type \"string\" when using `<invoke>.` However, argument attributes support JavaScript expressions which allow for other types of arguments. Example:\n```html\ncount=\"10\" <!-- string argument -->\ncount=\"${10}\"  <!-- number argument -->\n```\n\n\n## Structure Manipulation\n\n### attrs\n\nThe `attrs` attribute allows attributes to be dynamically added to an element at runtime. The value of the attrs attribute should be an expression that resolves to an object with properties that correspond to the dynamic attributes. For example:\n\n```html\n<div attrs=\"myAttrs\">\n    Hello World!\n</div>\n```\n\nGiven the following value for the `myAttrs` variable:\n\n```javascript\n{style: \"background-color: #FF0000;\", \"class\": \"my-div\"}\n```\n\nThe output would then be the following:\n\n```html\n<div style=\"background-color: #FF0000;\" class=\"my-div\">\n    Hello World!\n</div>\n```\n\n## Comments\n\nStandard HTML comments can be used to add comments to your template. The HTML comments will not show up in the rendered HTML.\n\nExample comments:\n\n```html\n<!-- This is a comment that will not be rendered -->\n<h1>Hello</h1>\n```\n\nIf you would like for your HTML comment to show up in the final output then you can use the custom `html-comment` tag:\n```html\n<html-comment>This is a comment that *will* be rendered</html-comment>\n<h1>Hello</h1>\n```\n\nOutput:\n\n```html\n<!--This is a comment that *will* be rendered-->\n<h1>Hello</h1>\n```\n\n## Helpers\n\nSince Marko template files compile into CommonJS modules, any Node.js module can be \"imported\" into a template for use as a helper module. For example, given the following helper module:\n\n_src/util.js_:\n```javascript\nexports.reverse = function(str) {\n    var out = \"\";\n    for (var i=str.length-1; i>=0; i--) {\n        out += str.charAt(i);\n    }\n    return out;\n};\n```\n\nThe above module can then be imported into a template as shown in the following sample template:\n\n_src/template.marko_:\n```html\n<require module=\"./util\" var=\"util\" />\n\n<div>${util.reverse('reverse test')}</div>\n```\n\n## Custom Tags and Attributes\n\nMarko supports extending the language with custom tags and attributes. A custom tag or a custom attribute __must have at least one dash__ to indicate that is not part of the standard HTML grammar.\n\nBelow illustrates how to use a simple custom tag:\n\n```html\n<div>\n    <my-hello name=\"World\"/>\n</div>\n```\n\nThe output of the above template might be the following:\n\n```html\n<div>\n    Hello World!\n</div>\n```\n\nFor information on how to use and create taglibs, please see the [Custom Taglibs](#custom-taglibs) section below.\n\n## Async Taglib\n\nThe async taglib allows portions of your template to be rendere asynchronously. An asynchronous fragment can be bound to a function that accepts an \"args\" objects and callback argument. When the data provider function completes and invokes the callback with the resulting data, the body of the async fragment is then rendered with the asynchronous data assigned to the specified variable. Asynchronous fragments allow parts of your page to render out-of-order while still providing the final HTML in the correct order.\n\nExample:\n\n```javascript\ntemplate.render({\n        userProfileDataProvider: function(arg, callback) {\n            var userId = arg.userId;\n            userProfileService.getUserProfile(userId, callback);\n        }\n    }, ...);\n```\n\n```html\n<async-fragment data-provider=\"data.userProfileDataProvider\"\n    var=\"userProfile\"\n    arg-userId=\"${data.userId}\">\n\n    <ul>\n        <li>\n            First name: ${userProfile.firstName}\n        </li>\n        <li>\n            Last name: ${userProfile.lastName}\n        </li>\n        <li>\n            Email address: ${userProfile.email}\n        </li>\n    </ul>\n\n</async-fragment>\n```\n\nFor more details, please see [https://github.com/raptorjs/marko-async](https://github.com/raptorjs/marko-async).\n\n## Layout Taglib\n\nMarko provides a `layout` taglib to support separating out layout from content. The usage of of the `layout` taglib is shown in the sample code below:\n\n_default-layout.marko:_\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title><layout-placeholder name=\"title\"/></title>\n</head>\n<body>\n    <h1 if=\"data.showHeader !== false\">\n        <layout-placeholder name=\"title\"/>\n    </h1>\n    <p>\n        <layout-placeholder name=\"body\"/>\n    </p>\n    <div>\n        <layout-placeholder name=\"footer\">\n            Default Footer\n        </layout-placeholder>\n    </div>\n</body>\n</html>\n```\n\n_Usage of `default-layout.marko`:_\n\n```html\n<layout-use template=\"./default-layout.marko\" show-header=\"$true\">\n    <layout-put into=\"title\">My Page</layout-put>\n    <layout-put into=\"body\">BODY CONTENT</layout-put>\n</layout-use>\n```\n\n\nFor more details, please see [https://github.com/raptorjs/marko-layout](https://github.com/raptorjs/marko-layout).\n\n# Custom Taglibs\n\n\n## Tag Renderer\n\nEvery tag should be mapped to a \"renderer\". A renderer is just a function that takes two arguments (`data` and `out`). The `data` argument is an arbitrary object that contains the data data for the renderer. The `out` argument is an [asynchronous rendering out](https://github.com/raptorjs/async-writer) that wraps an output stream. Output can be produced using `out.write(someString)` There is no class hierarchy or tie-ins to Marko when implementing a tag renderer. A simple tag renderer is shown below:\n\n```javascript\nmodule.exports = function(data, out) {\n    out.write('Hello ' + data.name + '!');\n}\n```\n\nIf, and only if, a tag has nested content, then a special `invokeBody` method will be added to the `data` object. If a renderer wants to render the nested body content then it must call the `invokeBody` method. For example:\n\n```javascript\nmodule.exports = function(data, out) {\n    out.write('BEFORE BODY');\n    if (data.invokeBody) {\n        data.invokeBody();\n    }\n    out.write('AFTER BODY');\n}\n```\n\nA tag renderer should be mapped to a custom tag by creating a `marko-taglib.json` as shown in the next few sections.\n\n## marko-taglib.json\n\n### Sample Taglib\n\n```json\n{\n    \"tags\": {\n        \"my-hello\": {\n            \"renderer\": \"./hello-renderer\",\n            \"attributes\": {\n                \"name\": \"string\"\n            }\n        }\n    }\n}\n```\n\n### Defining Tags\n\nTags can be defined by adding a `\"tags\"` property to your `marko-taglib.json`:\n\n```json\n{\n    \"tags\": {\n        \"my-hello\": {\n            \"renderer\": \"./hello-renderer\",\n            \"attributes\": {\n                \"name\": \"string\"\n            }\n        },\n        \"my-foo\": {\n            \"renderer\": \"./foo-renderer\",\n            \"attributes\": {\n                \"*\": \"string\"\n            }\n        }\n    }\n}\n```\n\nEvery tag should be associated with a renderer. When a custom tag is used in a template, the renderer will be invoked at render time to produce the HTML/output.\n\n#### Defining Attributes\n\nIf you provide attributes then the Marko compiler will do validation to make sure only the supported attributes are provided. A wildcard attribute (`\"*\"`) allows any attribute to be passed in. Below are sample attribute definitions:\n\n_Multiple attributes:_\n```javascript\n\"attributes\": {\n    \"message\": \"string\",     // String\n    \"my-data\": \"expression\", // JavaScript expression\n    \"*\": \"string\"            // Everything else will be added to a special \"*\" property\n}\n```\n\n### Scanning for Tags\n\nMarko supports a directory scanner to make it easier to maintain a taglib by introducing a few conventions:\n\n* The name of the tag directory will be the name of the tag\n* One tag per directory\n* All tag directories should be direct children of a parent directory\n* Every tag directory must contain a `renderer.js` that is used as the tag renderer or, alternatively, a `template.marko`\n* Each tag directory may contain a `marko-tag.json` file or the tag definition can be embedded into `renderer.js`\n\nWith this approach, `marko-taglib.json` will be much simpler:\n\n```json\n{\n    \"tags-dir\": \"./components\"\n}\n```\n\nGiven the following directory structure:\n\n* __components/__\n    * __my-hello/__\n        * renderer.js\n    * __my-foo/__\n        * template.marko\n    * __my-bar/__\n        * renderer.js\n        * marko-tag.json\n* marko-taglib.json\n\nThe following three tags will be exported:\n\n* `<my-hello>`\n* `<my-foo>`\n* `<my-bar>`\n\nDirectory scanning only supports one tag per directory and it will only look at directories one level deep. The tag definition can be embedded into the `renderer.js` file or it can be put into a separate `marko-tag.json`. For example:\n\n_In `renderer.js`:_\n\n```javascript\nexports.tag = {\n    \"attributes\": {\n        \"name\": \"string\"\n    }\n}\n```\n\n_In `marko-tag.json`:_\n\n```javascript\n{\n    \"attributes\": {\n        \"name\": \"string\"\n    }\n}\n```\n\n_NOTE: It is not necessary to declare the `renderer` since the scanner will automatically use `renderer.js` as the renderer._\n\n### Nested Tags\n\nIt is often necessary for tags to have a parent/child or ancestor/descendent relationship. For example:\n\n```html\n<ui-tabs>\n    <ui-tab label=\"Overview\"></ui-tab>\n    <ui-tab label=\"Language Guide\"></ui-tab>\n    <ui-tab label=\"JavaScript API\"></ui-tab>\n</ui-tabs>\n```\n\nMarko supports this by leveraging JavaScript closures in the compiled output. A tag can introduce scoped variables that are available to nested tags. This is shown in the sample `marko-taglib.json` below:\n\n```json\n{\n    \"tags\": {\n        \"ui-tabs\": {\n            \"renderer\": \"./tabs-tag\",\n            \"var\": \"tabs\"\n        },\n        \"ui-tab\": {\n            \"renderer\": \"./tab-tag\",\n            \"import-var\": {\n                \"tabs\": \"tabs\"\n            },\n            \"attributes\": {\n                \"title\": \"string\"\n            }\n        }\n    }\n}\n```\n\nIn the above example, the `<ui-tabs>` tag will introduce a scoped variable named `tabs` that is then automatically imported by the nested `<ui-tab>` tags. When the nested `<ui-tab>` tags render they can use the scoped variable to communicate with the renderer for the `<ui-tabs>` tag.\n\nThe complete code for this example is shown below:\n\n_components/tabs/renderer.js:_\n\n```javascript\nvar templatePath = require.resolve('./template.marko');\nvar template = require('marko').load(templatePath);\n\nmodule.exports = function render(data, out) {\n    var nestedTabs = [];  \n\n    // Invoke the body function to discover nested <ui-tab> tags\n    data.invokeBody({ // Invoke the body with the scoped \"tabs\" variable\n        addTab: function(tab) {\n            tab.id = tab.id || (\"tab\" + tabs.length);\n            nestedTabs.push(tab);\n        }\n    });\n\n    // Now render the markup for the tabs:\n    template.render({\n        tabs: nestedTabs\n    }, out);\n};\n```\n\n_components/tab/renderer.js:_\n\n```javascript\nmodule.exports = function render(data, out) {\n    // Register with parent but don't render anything\n    data.tabs.addTab(data);\n};\n```\n\n_components/tabs/template.marko:_\n\n```html\n<div class=\"tabs\">\n    <ul class=\"nav nav-tabs\">\n        <li class=\"tab\" for=\"tab in data.tabs\">\n            <a href=\"#${tab.id}\" data-toggle=\"tab\">\n                ${tab.title}\n            </a>\n        </li>\n    </ul>\n    <div class=\"tab-content\">\n        <div id=\"${tab.id}\" class=\"tab-pane\" for=\"tab in data.tabs\">\n            <invoke function=\"tab.invokeBody()\"/>\n        </div>\n    </div>\n</div>\n```\n\n\n## Taglib Discovery\n\nGiven a template file, the `marko` module will automatically discover all taglibs by searching relative to the template file. The taglib discoverer will search up and also look into `node_modules` to discover applicable taglibs.\n\nAs an example, given a template at path `/my-project/src/pages/login/template.marko`, the search path will be the following:\n\n1. `/my-project/src/pages/login/marko-taglib.json`\n2. `/my-project/src/pages/login/node_modules/*/marko-taglib.json`\n3. `/my-project/src/pages/marko-taglib.json`\n4. `/my-project/src/pages/node_modules/*/marko-taglib.json`\n5. `/my-project/src/marko-taglib.json`\n6. `/my-project/src/node_modules/*/marko-taglib.json`\n7. `/my-project/marko-taglib.json`\n8. `/my-project/node_modules/*/marko-taglib.json`\n\n# FAQ\n\n__Question:__ _Is Marko ready for production use?_\n\n__Answer__: Yes, Marko has been battle-tested at [eBay](http://www.ebay.com/) and other companies for well over a year and has been designed with high performance, scalability, security and stability in mind.\n\n<hr>\n\n__Question:__ _Can templates be compiled on the client?_\n\n__Answer__: Possibly, but it is not recommended and it will likely not work in older browsers. The compiler is optimized to produce small, high performance compiled templates, but the compiler itself is not small and it comes bundled with some heavyweight modules such as a [JavaScript HTML parser](https://github.com/fb55/htmlparser2). In short, always compile your templates on the server. The [RaptorJS Optimizer](https://github.com/raptorjs/optimizer) is recommended for including compiled templates as part of a web page.\n\n<hr>\n\n__Question:__ _Which web browsers are supported?_\n\n__Answer__: The runtime for template rendering is supported in all web browsers. If you find an issue please report a bug.\n\n<hr>\n\n__Question:__ _How can Marko be used with Express?_\n\n__Answer__: The recommended way to use Marko with Express is to bypass the Express view engine and instead have Marko render directly to the response stream as shown in the following code:\n\n```javascript\nvar template = require('marko').load(require.resolve('./template.marko'));\n\napp.get('/profile', function(req, res) {\n    template\n        .render({\n            name: 'Frank'\n        }, res);\n});\n```\n\nWith this approach, you can benefit from streaming and there is no middleman (less complexity).\n\nAlternatively, you can use the streaming API to produce an intermediate stream that can then be piped to the response stream as shown below:\n\n```javascript\nvar template = require('view-engine').load(require.resolve('./template.marko'));\n\napp.get('/profile', function(req, res) {\n    template.stream({\n            name: 'Frank'\n        })\n        .pipe(res);\n});\n```\n\n<hr>\n\n__Question:__ _What is the recommended directory structure for templates and \"partials\"_\n\n__Answer__: Your templates should be organized just like all other JavaScript modules. You should put your templates right next to the code that refers to them. That is, do not create a separate \"templates\" directory. For a sample Express app that uses Marko, please see [marko-express](https://github.com/raptorjs/raptor-samples/tree/master/marko-express).\n\n<hr>\n\n__Question:__ _How is Marko related to [RaptorJS](http://raptorjs.org)?_\n\n__Answer__: Marko is one of the modules that is part of the RaptorJS toolkit. It used to be a submodule, but now it has been split out into its own top-level Node.js module (for history, please see the [RaptorJS 3 Plan](https://github.com/raptorjs/raptorjs/wiki/RaptorJS-3-Plan) page).\n\n# Discuss\n\nPlease post questions or comments on the [RaptorJS Google Groups Discussion Forum](http://groups.google.com/group/raptorjs).\n\n# Contributors\n\n* [Patrick Steele-Idem](https://github.com/patrick-steele-idem) (Twitter: [@psteeleidem](http://twitter.com/psteeleidem))\n* [Phillip Gates-Idem](https://github.com/philidem/) (Twitter: [@philidem](https://twitter.com/philidem))\n\n# Contribute\n\nPull Requests welcome. Please submit Github issues for any feature enhancements, bugs or documentation problems.\n\n# License\n\nApache License v2.0\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/raptorjs/marko/issues"
  },
  "homepage": "https://github.com/raptorjs/marko",
  "_id": "marko@1.2.23",
  "dist": {
    "shasum": "843c2f9e96deaad22ccc2817657470b799684344"
  },
  "_from": "marko@~1.2.20",
  "_resolved": "http://registry.npmjs.org/marko/-/marko-1.2.23.tgz"
}
