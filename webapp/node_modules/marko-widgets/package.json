{
  "name": "marko-widgets",
  "description": "Module to support binding of behavior to rendered UI components rendered on the server or client",
  "repository": {
    "type": "git",
    "url": "https://github.com/raptorjs/marko-widgets.git"
  },
  "scripts": {
    "test": "mocha --ui bdd --reporter spec ./test && node_modules/.bin/jshint lib/ dust/ dust/"
  },
  "author": {
    "name": "Patrick Steele-Idem",
    "email": "pnidem@gmail.com"
  },
  "maintainers": "Patrick Steele-Idem <pnidem@gmail.com>",
  "dependencies": {
    "events": "^1.0.2",
    "raptor-dom": "^1.0.0",
    "raptor-dust": "^1.1.2",
    "raptor-json": "^1.0.1",
    "raptor-logging": "^1.0.1",
    "raptor-modules": "^1.0.5",
    "raptor-polyfill": "^1.0.0",
    "raptor-pubsub": "^1.0.2",
    "raptor-renderer": "^1.1.1",
    "raptor-util": "^1.0.0"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "dustjs-linkedin": "^2.3.4",
    "jshint": "^2.5.0",
    "mocha": "~1.15.1",
    "raptor-strings": "^1.0.0"
  },
  "license": "Apache License v2.0",
  "bin": {},
  "main": "lib/marko-widgets.js",
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "version": "1.1.12",
  "readme": "marko-widgets\n==============\n\nThe `marko-widgets` module provides a simple and efficient mechanism for binding behavior to UI components rendered on either the server or in the browser. This module also supports inter-widget communication and provides a simple framework that encourages best practices and makes it easy to \"wire up\" complex applications. Out of the box, bindings are provided for [Marko](https://github.com/raptorjs/marko) and [Dust](https://github.com/linkedin/dustjs). There is no complex widget class hierarchy or complex API and you are free to use jQuery or any other library for working with the DOM.\n\n![eBay Open Source](https://raw.githubusercontent.com/raptorjs/optimizer/master/images/ebay.png)\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n# Table of Contents\n\n- [Installation](#installation)\n- [Glossary](#glossary)\n- [Usage](#usage)\n\t- [Binding Behavior](#binding-behavior)\n\t- [Widget Config](#widget-config)\n\t- [Referencing Widgets](#referencing-widgets)\n\t- [Referencing Widget DOM Elements](#referencing-widget-dom-elements)\n\t- [Rendering Widgets in the Browser](#rendering-widgets-in-the-browser)\n- [API](#api)\n\t- [Widget](#widget)\n\t\t- [Methods](#methods)\n\t\t\t- [$(querySelector)](#$queryselector)\n\t\t\t- [addEventListener(eventType, listener)](#addeventlistenereventtype-listener)\n\t\t\t- [appendTo(targetEl)](#appendtotargetel)\n\t\t\t- [destroy()](#destroy)\n\t\t\t- [detach()](#detach)\n\t\t\t- [emit(eventType, arg1, arg2, ...)](#emiteventtype-arg1-arg2-)\n\t\t\t- [getEl(widgetElId)](#getelwidgetelid)\n\t\t\t- [getElId(widgetElId)](#getelidwidgetelid)\n\t\t\t- [insertAfter(targetEl)](#insertaftertargetel)\n\t\t\t- [insertBefore(targetEl)](#insertbeforetargetel)\n\t\t\t- [isDestroyed()](#isdestroyed)\n\t\t\t- [on(eventType, listener)](#oneventtype-listener)\n\t\t\t- [prependTo(targetEl)](#prependtotargetel)\n\t\t\t- [ready(callback)](#readycallback)\n\t\t\t- [replace(targetEl)](#replacetargetel)\n\t\t\t- [replaceChildrenOf(targetEl)](#replacechildrenoftargetel)\n\t\t\t- [rerender(data, callback)](#rerenderdata-callback)\n\t\t\t- [subscribeTo(targetEventEmitter)](#subscribetotargeteventemitter)\n\t\t- [Properties](#properties)\n\t\t\t- [this.el](#thisel)\n\t\t\t- [this.id](#thisid)\n\t\t\t- [this.widgets](#thiswidgets)\n\t- [WidgetCollection](#widgetcollection)\n\t\t- [Methods](#methods-1)\n\t\t\t- [forEach([id], callback)](#foreachid-callback)\n\t\t- [Properties](#properties-1)\n\t\t\t- [this.*](#this)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Installation\n\n```bash\nnpm install marko-widgets --save\n```\n\n# Glossary\n\nA few definitions before you get started:\n\n* A \"widget\" is the \"client-side behavior\" of a UI component\n* A widget instance has the following characteristics\n    * All widget instances are bound to a DOM element\n    * All widgets are [event emitters](http://nodejs.org/api/events.html)\n* Client-side behavior includes the following:\n    * Attaching DOM event listeners (mouse click, keyboard press, etc.)\n    * Attaching listeners to other widgets\n    * Manipulating the DOM\n    * Publishing client-side events\n    * etc.\n\n# Usage\n\n## Binding Behavior\n\nUsing the bindings for Marko, you can bind a widget to a rendered DOM element using the custom `w-bind` attribute as shown in the following sample template:\n\n```html\n<div class=\"my-component\" w-bind=\"./widget\">\n    <h1>Click Me</h1>\n</div>\n```\n\nThe widget bound to the `<div>` should then be implemented as a CommonJS module that exports a constructor function. During client-side initialization, a new instance of your widget will be created for each rendered DOM element that the widget is bound to. A sample widget implementation is shown in the following JavaScript code:\n\n__src/pages/index/widget.js:__\n\n```javascript\nfunction Widget(config) {\n    var rootEl = this.el; // this.el returns the root element that the widget is bound to\n    var self = this;\n\n    rootEl.addEventListener('click', function() {\n        self.addText('You clicked on the root element!');\n    });\n}\n\nWidget.prototype = {\n    addText: function(text) {\n        this.el.appendChild(document.createTextNode(text));\n    }\n};\n\nmodule.exports = Widget;\n```\n\nIn order for everything to work on the client-side we need to include the code for the `marko-widgets` module and the `./widget.js` module as part of the client bundle and we also need to use the custom `<init-widgets>` tag to let the client know which widgets rendered on the server need to be initialized on the client. To include the client-side dependencies will be using the [optimizer](https://github.com/raptorjs/optimizer) module and the taglib that it provides. Our final page template is shown below:\n\n__src/pages/index/template.marko:__\n\n```html\n<optimizer-page name=\"index\" package-path=\"./optimizer.json\" />\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Widgets Demo</title>\n    <optimizer-head/>\n</head>\n<body>\n    <!-- Bind a widget to a div element using the \"w-bind\" attribute -->\n    <div class=\"my-component\" w-bind=\"./widget\">\n        <h1>Click Me</h1>\n    </div>\n\n    <optimizer-body/>\n    <init-widgets/>\n</body>\n</html>\n```\n\nThe `optimizer.json` that includes the required client-side code is shown below:\n\n__src/pages/index/optimizer.json:__\n\n```javascript\n{\n    \"dependencies\": [\n        \"require marko-widgets\",\n        \"require ./widget\"\n    ]\n}\n```\n\nIn the above example, the final HTML will be similar to the following:\n\n```html\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Widgets Demo</title>\n    </head>\n    <body>\n        <div data-rwidget=\"/src/pages/index/widget\" id=\"w0\" class=\"my-component\">\n            <h1>Click Me</h1>\n        </div>\n        <script src=\"static/index-8947595a.js\" type=\"text/javascript\"></script>\n        <span style=\"display:none;\" data-ids=\"w0\" id=\"rwidgets\"></span>\n    </body>\n</html>\n```\n\n:arrow_forward: To try out and experiment with this code please see the documentation and source code for the [widgets-bind-behavior](https://github.com/raptorjs/raptor-samples/tree/master/widgets-bind-behavior) sample app.\n\n## Widget Config\n\nArbitrary widget configuration data determined at render time can be provided to the constructor of a widget. There are two options for attaching widget configuration data to a widget and those options are as follows:\n\n\n__Option 1) Using the `w-config` attribute:__\n\n_template.marko:_\n\n```html\n<div w-bind=\"./widget\" w-config=\"{message: 'Hello World'}\">\n...\n</div>\n```\n\n_widget.js:_\n\n```javascript\nfunction Widget(config) {\n    console.log(config.message); // Output: 'Hello World'\n}\n\nmodule.exports = Widget;\n```\n\n__Option 2) As a `widgetConfig` property of the input data model for a Marko template:__\n\n_renderer.js:_\n\n```javascript\nvar template = require('marko').load(require.resolve('./template.marko'));\n\nmodule.exports = function render(input, out) {\n    template.render({\n            widgetConfig: {\n                message: 'Hello World'\n            }\n        },\n        out);\n}\n```\n\n_template.marko:_\n\n```html\n<div w-bind=\"./widget\">\n...\n</div>\n```\n\n_widget.js:_\n\n```javascript\nfunction Widget(config) {\n    console.log(config.message); // Output: 'Hello World'\n}\n\nmodule.exports = Widget;\n```\n\n## Referencing Widgets\n\nThe `marko-widgets` taglib also provides support for allowing a widget to communicate directly with nested widgets. A nested widget can be assigned a widget ID (only needs to be unique within the scope of the containing widget) and the containing widget can then reference the nested widget by the assigned widget ID using the `this.widgets` collection.\n\nThe following HTML template fragment contains a widget that has three nested [sample-button](https://github.com/raptorjs/raptor-sample-ui-components/tree/master/components/sample-button) widgets. Each nested [sample-button](https://github.com/raptorjs/raptor-sample-ui-components/tree/master/components/sample-button) is assigned an ID (i.e. `primaryButton`, `successButton` and `dangerButton`).\n\n```html\n<div class=\"my-component\" w-bind=\"./widget\">\n    <div class=\"btn-group\">\n        <sample-button label=\"Click Me\" variant=\"primary\" w-id=\"primaryButton\"/>\n        <sample-button label=\"Click Me\" variant=\"success\" w-id=\"successButton\"/>\n        <sample-button label=\"Click Me\" variant=\"danger\" w-id=\"dangerButton\"/>\n    </div>\n    ...\n</div>\n```\n\nThe containing widget can then refer to a particular nested widget as shown in the following sample JavaScript code:\n\n```javascript\nthis.widgets.dangerButton.on('click', function() {\n    alert('You clicked on the danger button!');\n});\n```\n\nTo try out and experiment with this code please see the documentation and source code for the [widgets-communication](https://github.com/raptorjs/raptor-samples/tree/master/widgets-communication) sample app.\n\n## Referencing Widget DOM Elements\n\nDOM elements nested within a widget can be given unique IDs based on the containing widget's ID. These DOM elements can then be efficiently looked up by the containing widget using methods provided. The `w-el-id` custom attribute can be used to assign DOM element IDs to HTML elements that are prefixed with the widget's ID. For example, given the following HTML template fragment:\n\n```html\n<form w-bind=\"./widget\">\n    ...\n    <button type=\"submit\" w-el-id=\"submitButton\">Submit</button>\n    <button type=\"button\" w-el-id=\"cancelButton\">Cancel</button>\n</form>\n```\n\nAssuming the unique ID assigned to the widget is `w123`, the following would be the HTML output:\n\n```html\n<form id=\"w123\">\n    ...\n    <button type=\"submit\" id=\"w123-submitButton\">Submit</button>\n    <button type=\"button\" id=\"w123-cancelButton\">Cancel</button>\n</form>\n```\n\nFinally, to reference a widget's nested DOM element's the following code can be used in the containing widget:\n\n```javascript\nvar submitButton = this.getEl('submitButton'); // submitButton.id === 'w123-submitButton'\nvar cancelButton = this.getEl('cancelButton'); // cancelButton.id === 'w123-cancelButton'\n\nsubmitButton.style.border = '1px solid red';\n```\n\nThe object returned by `this.getEl()` will be a raw [HTML element](https://developer.mozilla.org/en-US/docs/Web/API/element). If you want a jQuery wrapped element you can do either of the following:\n\n\nOption 1) Use jQuery directly:\n\n```javascript\nvar $submitButton = $(this.getEl('submitButton'));\n```\n\nOption 2) Use the `this.$()` method:\n\n```javascript\nvar $submitButton = this.$('#submitButton');\n```\n\n## Rendering Widgets in the Browser\n\nTODO\n\n# API\n\n## Widget\n\n### Methods\n\n#### $(querySelector)\n\nThis is a convenience method for accessing a widget's DOM elements when jQuery is available. This mixin method serves as a proxy to jQuery to ease building queries based on widget element IDs.\n\nInternally, this jQuery proxy method will resolve widget element IDs to their actual DOM element ID by prefixing widget element IDs with the widget ID. For example, where this is a widget with an ID of `w123`:\n\n\n```javascript\nthis.$() ➡ $(\"#w123\")\nthis.$(\"#myEl\") ➡ $(\"#w123-myEl\")\n```\n\nThe usage of this mixin method is described below:\n\n__`$()`__\n\nConvenience usage to access the root widget DOM element wrapped as a jQuery object. All of the following are equivalent:\n\n```javascript\nthis.$()\n$(this.el)\n$(\"#\" + this.id)\n```\n\n__`$('#<widget-el-id>')`__\n\nConvenience usage to access a nested widget DOM element wrapped as a jQuery object. All of the following are equivalent:\n\n```javascript\nthis.$(\"#myEl\")\n$(this.getEl(\"myEl\"))\n$(\"#\" + this.getElId(\"myEl\"))\n```\n\n__`$('<selector>')`__\n\nConvenience usage to query nested DOM elements scoped to the root widget DOM element. All of the following are equivalent:\n\n```javascript\nthis.$(\"ul > li\")\n$(\"ul > li\", this.el)\n$(\"#\" + this.id + \" ul > li\")\n```\n\n__`$('<selector>', '<widget-el-id>')`__\n\nConvenience usage to query nested DOM elements scoped to a nested widget DOM element. All of the following are equivalent:\n\n```javascript\nthis.$(\"li.color\", \"colorsUL\")\nthis.$(\"#colorsUL li.color\")\n$(\"li.color\", this.getEl(\"colorsUL\"))\n$(\"#\" + this.getElId(\"colorsUL\") + \" li.color\")\n```\n\n__`$('#<widget-el-id> <selector>')`__\n\nConvenience usage to query nested DOM elements scoped to a nested widget DOM element. All of the following are equivalent:\n\n```javascript\nthis.$(\"#colorsUL li.color\")\nthis.$(\"li.color\", \"colorsUL\")\n$(\"li.color\", this.getEl(\"colorsUL\"))\n$(\"#\" + this.getElId(\"colorsUL\") + \" li.color\")\n```\n\n__`$(callbackFunction)`__\n\nConvenience usage to add a listener for the \"on DOM ready\" event and have the this object for the provided callback function be the current widget instance. All of the following are equivalent:\n\n```javascript\nthis.$(function() { /*...*/ });\n$(function() { /*...*/ }.bind(this));      // Using Function.prototype.bind\n$($.proxy(function() { /*...*/ }, this));\n```\n\n#### addEventListener(eventType, listener)\n\n#### appendTo(targetEl)\n\nMoves the widget's root DOM node from the current parent element to a new parent element. For example:\n\n```javascript\nthis.appendTo(document.body);\n```\n\n#### destroy()\n\nDestroys the widget by unsubscribing from all listeners made using the `subscribeTo` method and then detaching the widget's root element from the DOM. All nested widgets (discovered by querying the DOM) are also destroyed.\n\n#### detach()\n\nDetaches the widget's root element from the DOM by removing the node from its parent node.\n\n#### emit(eventType, arg1, arg2, ...)\n\nEmits an event. This method is inherited from EventEmitter (see [Node.js Events: EventsEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n\n#### getEl(widgetElId)\n\nReturns a nested DOM element by prefixing the provided `widgetElId` with the widget's ID. For Marko, nested DOM elements should be assigned an ID using the `w-el-id` custom attribute.  Returns `this.el` if no `widgetElId` is provided.\n\n#### getElId(widgetElId)\n\nSimilar to `getEl`, but only returns the String ID of the DOM element instead of the actual DOM element.\n\n#### insertAfter(targetEl)\n\n#### insertBefore(targetEl)\n\n#### isDestroyed()\n\n#### on(eventType, listener)\n\n#### prependTo(targetEl)\n\n#### ready(callback)\n\n#### replace(targetEl)\n\n#### replaceChildrenOf(targetEl)\n\n#### rerender(data, callback)\n\n#### subscribeTo(targetEventEmitter)\n\n### Properties\n\n#### this.el\n\nThe root [HTML element](https://developer.mozilla.org/en-US/docs/Web/API/element) that the widget is bound to.\n\n#### this.id\n\nThe String ID of the root [HTML element](https://developer.mozilla.org/en-US/docs/Web/API/element) that the widget is bound to.\n\n#### this.widgets\n\nAn instance of `WidgetCollection` (see below) that holds references to all nested widgets with an assigned widget ID (e.g., but using the `w-id` custom attribute). For example:\n\n```javascript\nvar submitButton = this.widgets.submitButton;\n```\n\n## WidgetCollection\n\n### Methods\n\n#### forEach([id], callback)\n\n### Properties\n\n#### this.*\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/raptorjs/marko-widgets/issues"
  },
  "homepage": "https://github.com/raptorjs/marko-widgets",
  "_id": "marko-widgets@1.1.12",
  "dist": {
    "shasum": "fa590f413ee2896dceb175113ba84ec22de1e82f"
  },
  "_from": "marko-widgets@~1.1.5",
  "_resolved": "http://registry.npmjs.org/marko-widgets/-/marko-widgets-1.1.12.tgz"
}
